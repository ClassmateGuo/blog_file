# 第一章-MySQL架构

## 逻辑架构
在高性能MySQL中,作者认为MySQL的逻辑架构可以分为3层
- 最上层的客户端包含其他服务/工具都有的服务,如:连接处理,身份验证,确保安全性等.
- 第二层是MySQL的核心功能层,包含查询解析,分析,优化,所有的内置函数,所有的跨存储引擎的功能,存储过程,触发器,视图等.
- 第三层是存储引擎层,复杂MySQL中数据的存储和提取.

![MySQL逻辑架构三层图](http://img.syilun.top/逻辑架构图.png)

## 连接管理
默认情况下,每个客户端连接都会在服务器`进程`中拥有一个`线程`,这个连接的查询只会在这个单独的线程中执行,这个线程驻留在一个内核或者CPU上.

## 安全性
客户端连接到MySQL服务器的时候,服务器会对其进行身份验证(基于用户名,发起的主机名,密码),连接成功后,服务器会继续验证该客户端是否具有其发出的每个查询的权限.
![连接管理与安全](http://img.syilun.top/连接管理与安全.png)

## 优化与执行
解析查询创建内部数据结构(解析树),然后对这棵树修修剪剪(各种优化).例如:`重写查询`,`决定表的读取顺序`,`选择合适的索引`等.
优化器不关心`table`使用什么存储引擎,但是存储引擎会对查询优化有影响.(因为每个存储引擎的某些功能,具体的操作成本,表数据的统计信息等等都是不同的)

## 并发控制
只要有多个查询需要同时修改数据,就会产生并发控制问题.(服务器级别,存储引擎级别)

## 读写锁
并发控制的经典解决方案: 处理并发读/写访问的系统通常实现一个由两种锁类型组成的锁系统,分别是共享锁(shared lock)和排他锁(exclusive lock),也称之为读锁(read lock)和写锁(write lock).
不考虑具体的锁机制,锁的概念: 
- 资源上的读锁是共享的(互不阻塞的)
- 写锁是排他的(一个写锁既会阻塞读锁也会阻塞其他写锁)

## 锁的粒度
锁的各种操作: 锁的获取,检查锁是会否空闲,释放锁等,都会增加系统的开销,消耗资源.所以不能锁定所有资源,应该只对需要修改的数据片段进行精确的锁定,让锁定的数据量最小化.
MySQL存储引擎分别提供了很多选择,可以实现自己的锁策略和锁粒度,以下是最重要的两种锁策略:
- 表锁(table lock) 是MySQL中最基本也是开销最小的锁策略.会锁定整张表,当客户端想对表进行写操作(插入,删除,更新等)时,需要先获取一个写锁,会阻塞其他客户端对这张表的所有读写操作.
- 行锁(row lock) 可以最大程度的支持并发处理(但是带来了最大的锁开销),这种策略允许多个客户端同时写操作不同的行,并且不会阻塞彼此.(行锁是在存储引擎中实现的)

## 事务
事务其实就是一组SQL语句,在执行这组语句的时候,如果其中任何一条语句因为各种原因导致无法执行,那么该组的所有语句都不执行.也就是**要么全部执行成功,要么全部执行失败**.
ACID
- A-原子性(atomicity),一个事务必须视为一个不可分割的组,整个事务中的所有操作要么全部成功提交,要么全部失败回滚,不可能只执行其中的一部分.
- C-一致性(consistency),数据库总是从一个一致性状态转换到下一个一致性状态.如果事务最终没有提交,该事务所做的任何修改都不会被保存到数据库中.
- I-隔离性(isolation),通常来说,一个事务所做的修改在最终提交前,对其他事务是不可见的.
- D-持久性(durability),一旦提交,事务所做的修改就会被永久保存到数据库中(即使数据库崩溃,数据也不会丢失).实际上持久化是一个模糊的概念,分了很多不同的级别.有些会提供非常强的安全保障,有些则未必.而且**不可能有100%的持久保证**.

## 隔离级别
ANSI SQL 标准定义了4种隔离级别(每种存储引擎的隔离级别都不尽相同).
- READ UNCOMMITTED(未提交读),在事务中可以查看其他事务还没有提交的修改(这种读取未提交的数据,也被称之为脏读(dirty read)).
- READ COMMITTED(提交读),一个事务可以看到其他事务在它**开始之后**提交的修改,但是在该事务提交之前,其所做的任何修改对其他事务都是不可见的(大部分数据库系统的默认隔离级别,但是MySQL不是).
- REPEATABLE READ(可重复读),解决了`读提交`级别的不可重复读问题,保证了在同一个事务中多次读取相同的同行数据的结果是一样的(但是存在一个幻读(phantom read)的问题).
    - 幻读:指的是当某个事务在读取某个范围内的记录时,另一个事务又在这个范围内插入了新的记录,当之前的事务再次读取该范围内的记录时,会产生换行(phantom row).
- SERIALIZABLE(可串行化),是最高的隔离级别,通过强制事务按序执行,使不同事务之间不可能产生冲突,从而解决了幻读问题(因为会在读取的每一行数据上都加锁,可能会导致大量的超时和锁争用问题).

## 死锁
两个或者多个事务相互持有和请求相同资源上的锁,产生了循环依赖.
- 当多个事务试图以不同的顺序锁定资源时会导致死锁
- 当多个事务锁定相同的资源时,也可能会造成死锁.

为了解决这个问题,数据库系统实现了个`死锁检测`和`锁超时机制`,更复杂的系统(InnoDB存储引擎)检查到`循环依赖`后会立即返回一个错误信息.**[InnoDB目前处理死锁的方式是将持有最少行级排他锁的事务回滚(这是一种最容易回滚的近似算法)]**

## 事务日志
事务日志采用的是追加写操作,是在硬盘中一小块区域内的`顺序I/O`,所以写入事务日志是一种相对比较快的操作(如果修改操作已经写入事务日志,那么即使系统在数据本身写入硬盘之前发生崩溃,存储引擎仍然可以在重新启动的时候恢复更改).

## MySQL中的事务
自动提交(AUTOCOMMIT)
默认情况下,单个INSERT,UPDATE,DELETE语句会被`隐式`包装在一个事务中,并在执行成功后立即提交,这被称之为自动提交模式.还有一些DDL语句也会具有相同效果.
⚠️:不要在应用程序中混合使用存储引擎,因为不同的存储引擎对于事务的处理是不一样的,有些事务是支持失败回滚,有些不支持的.

## 隐式锁定和显示锁定
InnoDB使用两阶段锁定协议(two-phase locking protocol).在事务执行期间,随时可以获取锁,但锁只有在提交或者回滚后才会释放,并且`所有的锁会同时释放`.

## 多版本并发控制
MySQL 的大多数事务型存储引擎使用的都不是简单的行级锁机制,会将行级锁和可以提高并发性能的`多版本并发控制(MVCC)`技术结合使用.
可以认为mvcc是行级锁的变种,它在很多情况下避免了加锁操作,开销很低.它的实现方式,不仅实现了非阻塞的读操作,写操作也只锁定必要的行.

## mvcc工作原理
使用数据在某个时间点的快照来实现的.-> 无论事务运行多长时间,都可以看到数据的一致视图;不同的事务可以在同一时间看到同一张表中的不同数据.

## mvcc实现
InnoDB通过为每个事务在启动时分配一个事务ID来实现MVCC.

## 复制
MySQL提供了一种原始方式来将一个节点执行的写操作分布到其他节点,这被称为复制.

## 数据结构文件
8.0版本MySQL将表的元数据重新设计为一种数据字典,包含在表的.idb文件中,使得表结构上的信息支持事务和原子级数据定义更改.

## InnoDB引擎
是MySQL的默认事务型存储引擎,也是最重要,使用最广泛的引擎.
- InnoDB是MySQL默认的通用存储引擎.
- InnoDB使用MVCC来实现高并发性,并实现了所有4个SQL标准隔离级别.
- InnoDB表是基于聚簇索引构建的.
- InnoDB内部做了很多优化: 从磁盘预取数据的可预测性预读;自动在内存中构建哈希索引以进行快速查找的自适应哈希索引;加速插入操作的插入缓冲区(insert buffer).
- InnoDB的行为是复杂的,例如"锁","实物模型"等.
- InnoDB在MySQL的5.6开始引入了在线DDL,在5.7和8.0中进行了扩充,就地(in-place)更改schema的机制允许在不使用完整表锁和外部工具的情况下进行特定的表更改操作,提高了InnoDB表的可操作性.

## JSON文档支持
JSON类型在5.7版本引入InnoDB,实现了JSON文档的自动验证,并优化了存储以允许快速读取.是对旧版本只能使用BLOB类型来处理JSON文档作为这种的重大改进.还引入了SQL函数来支持在JSON文档上的丰富操作.
8.0.7版本改进了在JSON数组上定义多值索引的能力,将常用访问模式匹配到可以映射JSON文档值的函数这一特性可以进一步加快对JSON类型的读取访问查询.

## 数据字典的变化
8.0版本删除了基于文件的表元数据存储,将其转移到了使用InnoDB表存储的数据字典中.

## 原子DDlock
8.0版本引入了原子数据定义更改(意味着数据定义语句现在要么全部成功提交,要么全部失败回滚).
这是通过创建DDL特定的Undo 日志和redo 日志来实现的.InnoDB 依赖这两种日志来跟踪变更(这是InnoDB经过验证的设计,已经扩展到MySQL服务器的操作中了).