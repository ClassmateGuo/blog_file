# 第四章-操作系统和硬件优化

## 简介
MySQL服务器的性能受限于整个系统最薄弱的环境,**而承载它的操作系统和硬件往往是限制因素**.`磁盘空间大小`,`可用内存和CPU资源`,`网络以及连接它们的组件`都限制了系统的最终容量.

## 什么限制了MySQL的性能?
不同的硬件组件都会影响MySQL的性能
- CPU:
最常见的瓶颈就是CPU耗尽(当MySQL尝试并行执行太多的查询,或者当少量的查询在CPU上运行太长时间时,就可能会发现CPU饱和).
- I/O:
I/O饱和也会发生,但是比CPU耗尽出现在的频率低得多.这是因为现在已经普遍使用了固态硬盘(SSD),固态硬盘比机械硬盘(HDD)通常要快10到20倍,所以即使查询需要访问磁盘,也仍然有良好的性能.
- 内存:
内存耗尽的情况也会发生,但是通常只会在试图将太多内存分配给MySQL时才会发生.

## 如何为MySQL选择CPU?
可以通过检查CPU使用率来确定工作负载是否受CPU限制,但是不能只看CPU的总体负载,而是要查看最重要查询的CPU使用率和I/O之间的平衡,注意CPU负载是否平衡,一般来说服务器需要达到2个目标.
- 低延迟(快速响应时间)
    - 需要更快的CPU,因为每个查询将只使用一个CPU.
- 高吞吐量
    - 如果可以同时运行多个查询,那么可以使用多个CPU为查询提供服务.

## 平衡内存和磁盘资源
配置大内存的主要原因并不是为了在内存中保存大量数据,而是为了避免磁盘I/O,因为磁盘I/O比访问内存中的数据要慢几个数量级.

### 缓存,读取和写入
如果内存足够大,那么可以完全避免磁盘读取操作(将所有数据存入内存中,每次读取就是命中缓存,这种情况下就不会从磁盘中进行物理读取).但是不能避免写操作.因为写入虽然可以像读取那样在内存中执行,但是`迟早必须被`写入磁盘(因为这样才能持久保存数据).
缓存可以允许写操作延迟,并且还允许它们以两种重要的方式组合在一起:
- 多次写操作,一次刷新
    - 一个数据片段可以在内存中多次被更改,并且不需要每一次都将更改后的新值写入磁盘,只有当数据被最终刷到磁盘时,自上次物理写入以来的所有修改都将被持久化.
- I/O合并
    - 许多不同的数据片段可以在内存中被修改,这些修改可以被收集在一起,因此物理写可以作为单个磁盘操作执行.
这就是为什么很多事务系统使用提前写日志(write-ahead logging)策略的原因,因为提前写日志允许在内存中更改页面,而不用将更改刷新到磁盘,这涉及到了随机I/O,速度非常慢.反之,将更改的记录写入顺序日志文件,这样要快的多.后台线程可以稍后再将修改过的页面刷新到磁盘,这样可以优化写操作的性能.
⚠️:写操作从缓冲中收益,因为可以将随机I/O转换为顺序I/O.
- 异步(缓冲)写操作通常由操作系统处理,并且是被成批处理的,这样可以更优地时被刷新到磁盘.
- 同步(无缓冲)写操作必须等待数据落盘.


## 固态存储
固态(闪存)存储已经是大多数数据库系统的标配.高质量的闪存设备具有以下性能:
- 比硬盘驱动器明显更好的随机读写性能够.
- 比硬盘驱动器更好的顺序读取性能.
- 比硬盘驱动器更好的并发支持.
- 最重要的时同时提升了随机I/O和并发性.

## RAID性能优化

### RAID是什么?
RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。

### RAID的功能(来自百度)
- 1、扩大了存储能力 可由多个硬盘组成容量巨大的存储空间。
- 2、降低了单位容量的成本 市场上最大容量的硬盘每兆容量的价格要大大高于普及型硬盘，因此采用多个普及型硬盘组成的阵列其单位价格要低得多。
- 3、提高了存储速度 单个硬盘速度的提高均受到各个时期的技术条件限制，要更进一步往往是很困难的，而使用RAID，则可以让多个硬盘同时分摊数据的读或写操作，因此整体速度有成倍地提高。
- 4、可靠性 RAID系统可以使用两组硬盘同步完成镜像存储，这种安全措施对于网络服务器来说是最重要不过的了。
- 5、容错性 RAID控制器的一个关键功能就是容错处理。容错阵列中如有单块硬盘出错，不会影响到整体的继续使用，高级RAID控制器还具有拯救数据功能。
- 6、对于IDE RAID来说，目前还有一个功能就是支持ATA/66/100。


### RAID级别比较
| 级别 | 概述 | 冗余 | 所需的磁盘 | 更快地读取 | 更快地写入 |
| -- | -- | -- | -- | -- | -- |
| RAID 0 | 便宜,快速,危险 | 否 | N | 是 | 是 |
| RAID 1 | 读取快读,简单,安全 | 是 | 通常是2块 | 是 | 否 |
| RAID 5 | 便宜,使用SSD时速度快 | 是 | N+1 | 是 | 视情况而定 |
| RAID 6 | 与RAID 5类似,但容错能力更强 | 是 | N+2 | 是 | 视情况而定 |
| RAID 10 | 昂贵,快速,安全 | 是 | 2N | 是 | 是 |
| RAID 50 | 用于非常大的数据存储 | 是 | 2(N+1) | 是 | 是 |

### RAID缓存
RAID缓存是物理暗转在硬件RAID控制器上的(相对)少量内存,当数据在磁盘和主机系统之间传输时,RAID缓存可以用来缓冲数据.以下是RAID卡使用缓存的一些可能原因:
- 缓存读操作
    - 当控制器从磁盘中读取一些数据并将其发送给主机系统后,控制器就可以存储这些数据;这将使控制器能满足未来对相同数据的请求,而无需再次访问磁盘.(⚠️:当时这是非常糟糕的RAID缓存使用方式,因为操作系统和数据库服务器都有更大的缓存.如果在其中(操作系统或数据库服务器)一个缓存中发生缓存命中,那么就不会使用RAID缓存中的数据;反之,如果(操作系统或数据库服务器)一个缓存都没命中,那么在RAID缓存中命中的可能性也会非常小,因为RAID缓存要小得多.所以从以上情况来看,使用RAID缓存来缓存读取数据是浪费内存.)
- 缓存预读取数据
    - ⚠️:如果数据库服务器正在执行自己的智能预读取(例如InnoDB所做的),RAID的预读操作可能没有帮助,并且还会干扰最重要的同步写操作的缓冲.
- 缓存写操作
    - RAID控制器可以将写操作缓冲到缓存中,并在以后调度.这样做有两个好处:首先可以以比实际在物理磁盘上执行写操作更快的速度给主机系统返回"成功";其次,可以累积写操作并更有效地执行写操作.
- 内部操作

PS:一般来说RAID控制器的内存是稀缺资源,所以要明智的使用它.用于读操作时一种浪费,将其用于写操作是提高I/O性能的一种重要方式.

## 网络配置
延迟和吞吐量是硬盘驱动器的限制因素,延迟和带宽也是网络连接的限制因素.
数据包丢失时一个常见问题,即使时1%的丢失也足以导致性能显著下降,因为协议栈中的各个层都会尝试通过等待一段时间然后重新发送数据包等策略来解决问题,这会增加额外的相应时间.另一个常见问题就是DNS解析异常中断或者缓慢.

## 选择文件系统
文件系统的选择在很大程度上取决于操作系统(比如Windows,实际上只有一两个选择,而且只有一个(NTFS)是真正可行的).
那么在GNU/Linux下,哪个文件系统对MySQL或者说对InnoDB性能最好?一些基准测试表明,大多数文件系统在很多方面都非常接近.只有在一些情况下,达到文件系统的处理极限时(例如需要处理高并发性,处理许多文件,碎片,等等),不同文件系统的差异才会体现出来.
⚠️:总的来说,最好使用`日志类型文件系统`,如ext4,XFS或ZFS.否则,系统崩溃侯,检查文件系统可能需要很长时间.

如果使用ext3或者其后续版本ext4,日志级别可以设置为3个,可以在`/etc/fstab`挂载选项中设置.
- data=writeback
    - 只记录元数据写入,会导致对元数据的写入与对数据的写入不同步.这是最快的配置,一般与InnoDB一起使用是安全的,因为InnoDB有自己的事务日志(⚠️:在某些特定的时间发生崩溃可能会导致MySQL8.0之前版本的frm文件损坏).
- data=orderde
    - 只记录元数据,但会在写元数据之前写入数据,这能保证一定程度的一致性.他只比`writeback选项`稍微慢点,而且在发生崩溃时要安全的多.
- data=journal
    - 提供原子日志行为->在将数据写入最终位置之前将数据先写入日志.该选项一般不是必要的,因为比其他两个选项有更高的开销.

### 常见文件系统的特性
| 文件系统 | 操作系统 | 日志支持 | 大目录支持 |
| -- | -- | -- | -- |
| ext3 | GNU/Linux | 可选 | 可选/部分支持 |
| ext4 | GNU/Linux | 支持 | 支持 |
| JFS | GNU/Linux | 支持 | 不支持 |
| NTFS | Windows | 支持 | 支持 |
| ReiserFs | GNU/Linux | 支持 | 支持 |
| UFS(Solaris) | Solaris | 支持 | 可调整 |
| UFS(FreeBSD) | FreeBSD | 不支持 | 可选/部分支持 |
| UFS2 | FreeBSD | 不支持 | 可选/部分支持 |
| XFS | GNU/Linux | 支持 | 支持 |
| ZFS | GNU/Linux,Solaris,FreeBSD | 支持 | 支持 |

## 选择磁盘队列调度器
在GNU/Linux上,队列调度器决定了对块设备的请求实际发送到底层设备的顺序.默认设置为`完全公平排队`,即CFQ(Complete Fair Queuing).这在笔记本电脑和台式机上偶尔使用是可以的,因为他有助于防止I/O饥渴.但是对于服务器来说很糟糕,因为在MySQL的工作负载类型下,CFQ会导致非常糟糕的相应时间,因为会不必要的阻塞队列中的一些请求.

## 内存和交换
在目前以来,确保更快的内存访问的最佳方法之一仍然是使用外部内存分配器(如tcmalloc或jemalloc)来替换内置的内存分配器(glibc).大量的基准测试表明,与glibc相比,这两种方法都能提高性能并减少内存碎片.

当操作系统因为没有足够的物理内存来容纳虚拟内存而将一些虚拟内存写入磁盘时,就会发生交换.交换对操作系统上运行的进程是透明的,只有操作系统知道特定的虚拟内存地址是在物理内存还是在磁盘上.

## 操作系统状态
操作系统提供了一些工具来帮助了解操作系统和硬件正在做什么(介绍工具,如何使用自行百度).

广泛可用的两个工具:
- iostat
- vmstat
其他有用的工具:
- mpstat (能输出每个CPU的统计数据)
- pt-diskstats (Percona工具箱的一部分,是交互式和按键驱动的,并且解决了iostat的一些问题,比如聚合显示读取和写入的方式,缺乏并发性的可见性.)
- perf (Linux剖析起)

## 总结:
MySQL需要的4种基本资源是CPU,内存,磁盘和网络资源.网络通常不会成为严重的瓶颈,但CPU,内存和磁盘会经常成为瓶颈.速度和数量的平衡实际上取决于`工作负载`,应该在预算允许的范围内努力实现更快更多的`平衡`.所期望的并发性越高,就越应该使用更多的CPU来支持`工作负载`.