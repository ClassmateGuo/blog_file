# 分数排名

## 题目详情
表: Scores

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| score       | decimal |
+-------------+---------+
Id是该表的主键。
该表的每一行都包含了一场比赛的分数。Score是一个有两位小数点的浮点值。
 

编写 SQL 查询对分数进行排序。排名按以下规则计算:

分数应按从高到低排列。
如果两个分数相等，那么两个分数的排名应该相同。
在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。
按 score 降序返回结果表。

查询结果格式如下所示。

 

示例 1:

输入: 
Scores 表:
+----+-------+
| id | score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
输出: 
+-------+------+
| score | rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+

## 插入MySQL

```sql
CREATE TABLE `Scores` (
  `id` int NOT NULL AUTO_INCREMENT,
  `score` decimal(10,2) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
```


```sql
INSERT INTO Scores ( score )
VALUES
	( 3.50 ),
	( 3.65 ),
	( 4.00 ),
	( 3.85 ),
	( 4.00 ),
	( 3.65 );
```


## 解答分析

### 不使用函数的解法
```sql
SELECT
	Score,
	( SELECT count( DISTINCT score ) FROM Scores a WHERE a.score >= b.score ) AS 'Rank' 
FROM
	Scores b 
ORDER BY
	Score DESC;
```


按照题目需求,主要的是做rank排名,那么就涉及到分数大小的对比
1.首先在外部查询中针对score做倒序排序,大的分数排在上面,小的分数排在下面
Score
4.00
4.00
3.85
3.65
3.65
3.50

2.在子查询中做判断,统计出大于等于当前分数(b.score)的分数个数:
- 如果当前分数为4.00,那么大于等于4.00的个数有2个
- 如果当前分数为3.85,那么大于等于3.85的个数有3个
- 如果当前分数为3.65,那么大于等于3.65的个数有4个
- 如果当前分数为3.50,那么大于等于3.50的个数有6个
 
输出的结果如下,并不符合我们所需要的结果
Score	Rank
4.00	2
4.00	2
3.85	3
3.65	5
3.65	5
3.50	6

其实可以看出,上面输出的结果是因为有重复的score导致统计出了问题,因为4.00,3.65分别都有2个相同的分数.那么在子查询的count()函数中添加去重操作
可以得出正确的结果:
Score	Rank
4.00	1
4.00	1
3.85	2
3.65	3
3.65	3
3.50	4

###  使用函数的解法

因为MySQL的升级,带来了许多便捷的函数,以下就是可以用于排序的两个函数

#### rank
简介
RANK()函数为结果集的分区中的每一行分配一个排名。行的等级由一加上前面的等级数指定。

使用姿势
```sql
SELECT
	Score,
	rank() over ( ORDER BY Score DESC ) 'Rank' 
FROM
	Scores;
```
输出结果
Score	Rank
4.00	1
4.00	1
3.85	3
3.65	4
3.65	4
3.50	6

发现Rank排名并不是连续的,因为rank()函数的这一特性导致的`行的等级由一加上前面的等级数指定。`

#### dense_rank
简介
DENSE_RANK()是一个窗口函数，它为分区或结果集中的每一行分配排名，而排名值没有间隙。行的等级从行前的不同等级值的数量增加1。
使用姿势
```sql
SELECT
	Score,
	dense_rank() over ( ORDER BY Score DESC ) 'Rank' 
FROM
	Scores;
```
输出结果
>Score	Rank
4.00	1
4.00	1
3.85	2
3.65	3
3.65	3
3.50	4

发现使用dense_rank()能够完美达成我们所需要的效果