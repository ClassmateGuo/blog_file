## Redis 如何应对并发访问？

为了保证并发访问的正确性，Redis 提供了两种方法，分别是加锁和原子操作：
+ 加锁是一种常用的方法，在读取数据前，客户端需要先获得锁，否则就无法进行操作。当一个客户端获得锁后，就会一直持有这把锁，直到客户端完成数据更新，才释放这把锁。
  + 存在两个问题：
    + 1、加锁操作太多，会降低系统的并发访问性能；
    + 2、Redis 客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作。

+ 原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。这样一来，既能保证并发控制，还能减少对系统并发性能的影响。


## 并发访问中需要对什么进行控制？

并发访问控制对应的操作主要是数据修改操作。当客户端需要修改数据时，基本流程分成两步：

1. 客户端先把数据读取到本地，在本地进行修改；
2. 客户端修改完数据后，再写回 Redis。


这个流程叫做`“读取 - 修改 - 写回”`操作（`Read-Modify-Write`，简称为 `RMW `操作）。当有多个客户端对同一份数据执行 `RMW` 操作的话，就需要让 `RMW` 操作涉及的代码以原子性方式执行。访问同一份数据的 `RMW` 操作代码，就叫做 ***临界区代码***。

> 不过，当有多个客户端并发执行临界区代码时，就会存在一些潜在问题

### 临界区代码问题

> 如果对临界区代码的执行没有控制机制，就会出现数据更新错误。

**举个例子：**
假设现在有两个客户端 `A` 和 `B`，同时执行刚才的临界区代码，就会出现错误：

![临界区代码错误示例](.pic/2023-03-27-%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B.png)

可以看到，客户端 `A` 在 `t1` 时读取库存值 `10` 并扣减 `1`，在 `t2` 时，客户端 `A` 还没有把扣减后的库存值 `9` 写回 Redis，而在此时，客户端 `B` 读到库存值 `10`，也扣减了 `1`，`B` 记录的库存值也为 `9` 了。等到 `t3 `时，`A` 往 Redis 写回了库存值 `9`，而到 `t4` 时，`B` 也写回了库存值 `9`。

如果按正确的逻辑处理，客户端 `A` 和 `B` 对库存值各做了一次扣减，库存值应该为 `8`。所以，这里的库存值明显更新错了。

> 出现这个现象的原因是，临界区代码中的客户端读取数据、更新数据、再写回数据涉及了三个操作，而这三个操作在执行时并 ***不具有互斥性*** ，**多个客户端基于相同的初始值进行修改，而不是基于前一个客户端修改后的值再修改**。


## Redis 的两种原子操作方法

为了实现并发控制要求的临界区代码互斥执行，Redis 的原子操作采用了两种方法：
+ 把多个操作在 Redis 中实现成一个操作，也就是单命令操作；


+ 把多个操作写到一个 `Lua` 脚本中，以原子性方式执行单个 `Lua` 脚本。

### 单命令操作

Redis 提供了 `INCR/DECR` 命令，把这三个操作转变为一个原子操作了。`INCR/DECR` 命令可以对数据进行增值 / 减值操作，而且它们本身就是单个命令操作，Redis 在执行它们时，本身就具有互斥性。

> 如果执行的 `RMW` 操作是对数据进行增减值的话，Redis 提供的原子操作 `INCR` 和 `DECR` 可以直接帮助进行并发控制。


### `Lua`脚本
如果要执行的操作不是简单地增减数据，而是有更加复杂的判断逻辑或者是其他操作，那么，Redis 的单命令操作已经无法保证多个操作的互斥执行了，就需要用到 `Lua` 脚本。

> Redis 会把整个 `Lua` 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 `Lua` 脚本中操作的原子性。如果有多个操作要执行，但是又无法用 `INCR/DECR` 这种命令操作来实现，就可以把这些要执行的操作编写到一个 `Lua` 脚本中。然后，可以使用 Redis 的 `EVAL` 命令来执行脚本。这样一来，这些操作在执行时就具有了互斥性。