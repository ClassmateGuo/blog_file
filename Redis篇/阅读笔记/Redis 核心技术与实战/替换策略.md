## Redis 缓存有哪些淘汰策略？
Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略。可以按照是否会进行数据淘汰把它们分成两类：

+ 不进行数据淘汰的策略，只有 noeviction 这一种。
+ 会进行淘汰的 7 种其他策略。
  + 可以再进一步根据淘汰候选数据集的范围把它们分成两类：
    + 在设置了过期时间的数据中进行淘汰，包括 `volatile-random`、`volatile-ttl`、`volatile-lru`、`volatile-lfu`（Redis 4.0 后新增）四种。
    + 在所有数据范围内进行淘汰，包括 `allkeys-lru`、`allkeys-random`、`allkeys-lfu`（Redis 4.0 后新增）三种。


默认情况下，Redis 在使用的内存空间超过 `maxmemory` 值时，并不会淘汰数据，也就是设定的 `noeviction` 策略。
> 对应到 Redis 缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。

再分析下 `volatile-random`、`volatile-ttl`、`volatile-lru` 和 `volatile-lfu` 这四种淘汰策略。它们筛选的候选数据范围，被限制在 ***已经设置了过期时间*** 的键值对上。
> 所以，即使缓存没有写满，这些数据如果过期了，也会被删除。
那么，这四种策略的具体筛选规则是怎样的？
+ volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，**越早过期的越先被删除**。
+ volatile-random 就像它的名称一样，在设置了过期时间的键值对中，**进行随机删除** 。
+ volatile-lru 会 **使用 `LRU` 算法** 筛选设置了过期时间的键值对。
+ volatile-lfu 会 **使用 `LFU` 算法** 选择设置了过期时间的键值对。

`allkeys-lru`、`allkeys-random`、`allkeys-lfu` 这三种淘汰策略的备选淘汰数据范围，就扩大到了所有键值对，无论这些键值对是否设置了过期时间。它们筛选规则是：
+ allkeys-random 策略，从 **所有键值对中随机选择** 并删除数据
+ allkeys-lru 策略，**使用 `LRU` 算法在所有数据** 中进行筛选。
+ allkeys-lfu 策略，**使用 `LFU` 算法在所有数据** 中进行筛选。

`LRU` 算法的全称是 `Least Recently Used`，从名字上就可以看出，这是按照最近最少使用的原则来筛选数据，***最不常用的数据会被筛选出来***，而最近频繁使用的数据会留在缓存中。
> `LRU `会把所有的数据组织成一个链表，链表的头和尾分别表示 `MRU` 端和 `LRU` 端，分别代表 ***最近最常使用*** 的数据和 ***最近最不常用*** 的数据。

![LRU算法筛选举例](.pic/2023-03-23-LRU%E7%AE%97%E6%B3%95%E7%AD%9B%E9%80%89%E4%B8%BE%E4%BE%8B.png)

现在有数据 `6、3、9、20、5`。如果数据 `20` 和 `3` 被先后访问，它们都会从现有的链表位置移到 `MRU` 端，而链表中在它们之前的数据则相应地往后移一位。因为， `LRU` 算法选择删除数据时，都是从 `LRU` 端开始，所以把刚刚被访问的数据移到 `MRU` 端，就可以让它们尽可能地留在缓存中。

如果有一个新数据 `15` 要被写入缓存，但此时已经没有缓存空间了，也就是链表没有空余位置了，那么，LRU 算法做两件事：
+ 数据 `15` 是刚被访问的，所以它会被放到 `MRU` 端；
+ 算法把 `LRU` 端的数据 `5` 从缓存中删除，相应的链表中就没有数据 `5` 的记录了。

> 其实， `LRU` 算法背后的想法非常朴素：它认为刚刚被访问的数据，肯定还会被再次访问，所以就把它放在 `MRU` 端；长久不访问的数据，肯定就不会再被访问了，所以就让它逐渐后移到 `LRU` 端，在缓存满时，就优先删除它。
>
> 不过， `LRU` 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 `MRU` 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。

所以，在 Redis 中，LRU 算法被做了简化，***Redis 默认会记录每个数据的最近一次访问的时间戳*** （由键值对数据结构 `RedisObject` 中的 `lru` 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 `N` 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 `N` 个数据的 `lru` 字段，***把 `lru` 字段值最小的数据从缓存中淘汰出去***。

Redis 提供了一个配置参数 `maxmemory-samples`，这个参数就是 Redis 选出的数据个数 `N`。例如，我们执行如下命令，可以让 Redis 选出 100 个数据作为候选数据集：
```
CONFIG SET maxmemory-samples 100
```

当需要再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。这儿的挑选标准是：***能进入候选集合的数据的 `lru` 字段值必须小于候选集合中最小的 lru 值。*** 当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了 `maxmemory-samples`，Redis 就把候选数据集中 `lru` 字段值最小的数据淘汰出去。

> 这样一来，Redis 缓存不用为所有的数据维护一个大链表，也不用在每次数据访问时都移动链表项，提升了缓存的性能。

### 三个使用建议

1、**优先使用 allkeys-lru 策略。** 这样，可以充分利用 `LRU` 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，建议你使用 `allkeys-lru` 策略。

2、如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 `allkeys-random `策略，随机选择淘汰的数据就行。

3、**如果你的业务中有置顶的需求，** 比如置顶新闻、置顶视频，那么，可以使用 `volatile-lru` 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。

## 如何处理被淘汰的数据？
一旦被淘汰的数据选定后，如果这个数据是干净数据，那么就直接删除；如果这个数据是脏数据，需要把它写回数据库：
![淘汰数据示意图](.pic/2023-03-23-%E6%B7%98%E6%B1%B0%E6%95%B0%E6%8D%AE%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

**如何判断一个数据是干净还是脏的呢？**

干净数据和脏数据的区别就在于，和最初从后端数据库里读取时的值相比，有没有被修改过：

+ 干净数据一直没有被修改，所以后端数据库里的数据也是最新值。在替换时，它可以被直接删除。

+ 脏数据就是曾经被修改过的，已经和后端数据库中保存的数据不一致了。此时，如果不把脏数据写回到数据库中，这个数据的最新值就丢失了，就会影响应用的正常使用。