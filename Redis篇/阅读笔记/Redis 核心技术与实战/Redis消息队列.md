# Redis 适合做消息队列嘛？

这个问题，关系着两方面的核心问题：
1. 消息队列的消息存取需求是什么？
2. Redis 如何实现消息队列的需求？

## **消息队列的消息存取需求**

**介绍一下消息队列存取消息的过程：**

> 在分布式系统中，当两个组件要基于消息队列进行通信时，
一个组件会把要处理的数据以消息的形式传递给消息队列，然后，这个组件就可以继续执行其他操作了；
远端的另一个组件从消息队列中把消息读取出来，再在本地进行处理。

**举个例子：**

> 假设组件 1 需要对采集到的数据进行求和计算，并写入数据库，但是，消息到达的速度很快，组件 1 没有办法及时地既做采集，又做计算，并且写入数据库。
> 
> 所以，我们可以使用基于消息队列的通信，让组件 1 把数据 x 和 y 保存为 JSON 格式的消息，再发到消息队列，这样它就可以继续接收新的数据了。组件 2 则异步地从消息队列中把数据读取出来，在服务器 2 上进行求和计算后，再写入数据库。

**过程如图所示**：

![基于消息队列的组件通信](.pic/2023-03-18-%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.png)

### **消息队列存取消息的三要素**
> 消息队列在存取消息时，必须要满足三个需求，分别是：消息保序、处理重复的消息和保证消息可靠性。分别是消息保序、处理重复的消息和保证消息可靠性。

#### **需求一：消息保序**

> 虽然消费者是异步处理消息，但是，消费者仍然需要按照生产者发送消息的顺序来处理消息，避免后发送的消息被先处理了。对于要求消息保序的场景来说，一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。


#### **需求二：重复消息处理**

> 消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时，消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。

#### **需求三：消息可靠性保证**

> 消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。

**Redis 的 List 和 Streams 两种数据类型，就可以满足消息队列的这三个需求。**

## **Redis 如何实现消息队列**

### **基于 List 的消息队列解决方案**

#### **保序**
List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。
>具体来说，生产者可以使用 LPUSH 命令把要发送的消息依次写入 List，而消费者则可以使用 RPOP 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理。
>
>**潜在风险：**
>
>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP 命令（比如使用一个 while(1) 循环）。如果有新消息写入，RPOP 命令就会返回结果，否则，RPOP 命令返回空值，再继续循环。
>
>所以，即使没有新消息写入 List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。)

为了解决这个问题，Redis 提供了 BRPOP 命令。**BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。**和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。

#### **重复消息处理**
List 本身是不会为每个消息生成 ID 号的。
>所以，消息的全局唯一 ID 号就需要生产者程序在发送消息前自行生成。生成之后，在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。

#### **消息可靠性**
当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。
>为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。

#### **存在的隐患**
可以发现，基于List 类型，可以满足分布式组件对于消息队列的三大需求。但是，在用List 做消息队列时，可能还会遇到一个问题：
>**生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力**

希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。**但是，List 类型并不支持消费组的实现。**


### **基于 Streams 的消息队列解决方案**

Streams 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令：
+ XADD：插入消息，保证有序，可以自动生成全局唯一 ID；
+ XREAD：用于读取消息，可以按 ID 读取数据；
+ XGROUP：用于创建消费组；
+ XREADGROUP：按消费组形式读取消息；
+ XPENDING：可以用来查询每个消费组内所有消费者已读取但尚未确认的消息；
+ XACK：用于向消息队列确认消息处理已完成。

1. 使用 XADD 命令向名称为 mqstream 的消息队列中插入一条消息，消息的键是 repo，值是5.
```redis
XADD mqstream * repo 5 
# "1599203861727-0"
# *，表示让 Redis 为插入的数据自动生成一个全局唯一的 ID (也可以自己设置)
# 可以看到，消息的全局唯一 ID 由两部分组成，第一部分“1599203861727”是数据插入时，以毫秒为单位计算的当前服务器时间，第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1599203861727-0”就表示在“1599203861727”毫秒内的第 1 条消息。
```
2. 使用 XREAD 命令，指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取

```redis
XREAD BLOCK 100 STREAMS  mqstream 1599203861727-0
# 从 ID 号为 1599203861727-0 的消息开始，读取后续的所有消息
1) 1) "mqstream"
   2) 1) 1) "1599274912765-0"
         2) 1) "repo"
            2) "3"
      2) 1) "1599274925823-0"
         2) 1) "repo"
            2) "2"
      3) 1) "1599274927910-0"
         2) 1) "repo"
            2) "1"
```

消费者也可以在调用 XRAED 时设定 block 配置项，实现类似于 BRPOP 的阻塞读取操作。当消息队列中没有消息时，一旦设置了 block 配置项，XREAD 就会阻塞，阻塞的时长可以在 block 配置项进行设置。

```redis
XREAD block 10000 streams mqstream $
(nil)
(10.00s)
# 命令最后的“$”符号表示读取最新的消息，同时，我们设置了 block 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。下面命令中的 XREAD 执行后，消息队列 mqstream 中一直没有消息，所以，XREAD 在 10 秒后返回空值（nil）。
```

3. 使用 XGROUP 创建消费组

```redis
XGROUP create mqstream group1 0
OK
# 创建一个名为 group1 的消费组，这个消费组消费的消息队列是 mqstream。
```

4. 使用 XREADGROUP 命令让 group1 消费组里的消费者 consumer1 从 mqstream 中读取所有消息，其中，命令最后的参数“>”，表示从第一条尚未被消费的消息开始读取。因为在 consumer1 读取消息前，group1 中没有其他消费者读取过消息，所以，consumer1 就得到 mqstream 消息队列中的所有消息了（一共 4 条）。
```redis
XREADGROUP group group1 consumer1 streams mqstream >
1) 1) "mqstream"
   2) 1) 1) "1599203861727-0"
         2) 1) "repo"
            2) "5"
      2) 1) "1599274912765-0"
         2) 1) "repo"
            2) "3"
      3) 1) "1599274925823-0"
         2) 1) "repo"
            2) "2"
      4) 1) "1599274927910-0"
         2) 1) "repo"
            2) "1"
```
需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。
```redis
# 执行完上面的 XREADGROUP 命令后，再执行下面的命令，让 group1 内的 consumer2 读取消息时，consumer2 读到的就是空值，因为消息已经被 consumer1 读取完了

XREADGROUP group group1 consumer2  streams mqstream 0
1) 1) "mqstream"
   2) (empty list or set)
```

>为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。

5. 用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。查看一下 group2 中各个消费者已读取、但尚未确认的消息个数。其中，XPENDING 返回结果的第二、三行分别表示 group2 中所有消费者读取的消息最小 ID 和最大 ID

```redis
XPENDING mqstream group2
1) (integer) 3
2) "1599203861727-0"
3) "1599274925823-0"
4) 1) 1) "consumer1"
      1) "1"
   1) 1) "consumer2"
      1) "1"
   2) 1) "consumer3"
      1) "1"
```

进一步查看某个消费者具体读取了哪些数据，可以执行下面的命令：

```redis
XPENDING mqstream group2 - + 10 consumer2
1) 1) "1599274912765-0"
   2) "consumer2"
   3) (integer) 513336
   4) (integer) 1
```
可以看到，consumer2 已读取的消息的 ID 是 1599274912765-0。

6. 一旦消息 1599274912765-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除。

```redis
XACK mqstream group2 1599274912765-0
(integer) 1

# 再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息了。
XPENDING mqstream group2 - + 10 consumer2
(empty list or set)
```


![List和Streams的区别](.pic/2023-03-18-List%E5%92%8CStreams%E7%9A%84%E5%8C%BA%E5%88%AB.png)