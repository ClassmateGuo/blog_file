
## 前提

在使用 Redis 时，经常会遇到这样一个问题：明明做了数据删除，数据量已经不大了，为什么使用 top 命令查看时，还会发现 Redis 占用了很多内存呢？

> 因为，当数据删除后，Redis **释放的内存空间会由内存分配器管理，并不会立即返回给操作系统**。所以，操作系统仍然会记录着给 Redis 分配了大量内存。

但是，这存在一个潜在的风险点：
> Redis 释放的内存空间可能并不是连续的，那么，这些不连续的内存空间很有可能处于一种闲置的状态。这就会导致一个问题：**虽然有空闲空间，Redis 却无法用来保存数据**，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。

## 什么是内存碎片？

通常情况下，内存空间闲置，往往是因为操作系统发生了较为严重的内存碎片。那么，什么是内存碎片呢？

> 借助高铁的车厢座位来进行解释。假设一个车厢的座位总共有 60 个，现在已经卖了 57 张票，你和 2 个小伙伴要乘坐高铁出门旅行，刚好需要三张票。不过，你们想要坐在一起，这样可以在路上聊天。但是，在选座位时，你们却发现，已经买不到连续的座位了。于是，你们只好换了一趟车。这样一来，你们需要改变出行时间，而且这趟车就空置了三个座位。

![举例示意图](.pic/2023-03-20-%E4%B8%BE%E4%BE%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

通过上面的例子和图，可以理解，虽然操作系统的剩余内存空间总量足够，但是，应用申请的是一块***连续地址空间的 N 字节***，但在剩余的内存空间中，没有大小为 N 字节的连续空间了，那么，这些剩余空间就是内存碎片（比如上图中的“空闲 2 字节”和“空闲 1 字节”，就是这样的碎片）。

## Redis 内存碎片是如何形成的？

内存碎片的形成有内因和外因两个层面的原因。内因是操作系统的内存分配机制；外因是 Redis 的负载特征。

### 内因：内存分配器的分配策略

> 内存分配器的分配策略就决定了操作系统无法做到“按需分配”。这是因为，内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。

Redis 可以使用 `libc、jemalloc、tcmalloc` 多种内存分配器来分配内存，默认使用 `jemalloc`。

jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如` 8 字节、16 字节、32 字节、48 字节`，…, `2KB、4KB、8KB` 等。***当程序申请的内存最接近某个固定值时，`jemalloc` 会给它分配相应大小的空间。***

> 这样的分配方式本身是为了减少分配次数。例如，Redis 申请一个 20 字节的空间保存数据，jemalloc 就会分配 32 字节，此时，如果应用还要写入 10 字节的数据，Redis 就不用再向操作系统申请空间了，因为刚才分配的 32 字节已经够用了，这就避免了一次分配操作。


### 外因：键值对大小不一样和删改操作

**外因一：** 

> 不同业务应用的数据保存在 Redis 中，这会带来**不同大小的键值对**，Redis 申请内存空间分配时，本身就会有大小不一的空间需求。（例如：应用 A 保存 6 字节数据，jemalloc 按分配策略分配了 8 字节，如果后续应用 A 不在保存新数据，那么就多出来 2 字节空间的内存碎片了）

![外因一示例图](.pic/2023-03-20-%E5%A4%96%E5%9B%A0%E4%B8%80%E7%A4%BA%E4%BE%8B%E5%9B%BE.png)

**外因二：** 

> 保存在 Redis 中的键值对会被**修改和删除**，这会导致空间的扩容和释放。（如果修改后的键值对变大或变小了，就需要占用额外的空间或者释放不用的空间；删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。）

![外因二示意图](.pic/2023-03-20-%E5%A4%96%E5%9B%A0%E4%BA%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

> 一开始，应用 A、B、C、D 分别保存了 3、1、2、4 字节的数据，并占据了相应的内存空间。然后，应用 D 删除了 1 个字节，这个 1 字节的内存空间就空出来了。紧接着，应用 A 修改了数据，从 3 字节变成了 4 字节。为了保持 A 数据的空间连续性，操作系统就需要把 B 的数据拷贝到别的空间，比如拷贝到 D 刚刚释放的空间中。此时，应用 C 和 D 也分别删除了 2 字节和 1 字节的数据，整个内存空间上就分别出现了 2 字节和 1 字节的空闲碎片。如果应用 E 想要一个 3 字节的连续空间，显然是不能得到满足的。因为，***虽然空间总量够，但却是碎片空间，并不是连续的***。


## 如何判断是否有内存碎片？

Redis 自身提供了 INFO 命令，可以用来查询内存使用的详细信息，命令如下：
```
INFO memory
# Memory
used_memory:1073741736
used_memory_human:1024.00M
used_memory_rss:1997159792
used_memory_rss_human:1.86G
…
mem_fragmentation_ratio:1.86
```

这里有一个 `mem_fragmentation_ratio` 的指标，它表示的就是 Redis **当前的内存碎片率**。那么，这个碎片率是怎么计算的呢？其实，就是上面的命令中的两个指标 `used_memory_rss` 和 `used_memory` 相除的结果。

```
mem_fragmentation_ratio = used_memory_rss / used_memory
当前内存碎片率 = 实际分配内存空间 / 保存数据实际申请使用内存空间
```

`used_memory_rss` 是**操作系统实际分配给 Redis 的物理内存空间**，里面就包含了碎片；而 `used_memory` 是 Redis 为了**保存数据实际申请使用的空间**。

**根据上面，知道了这个指标，该如何使用呢？**

+ **mem_fragmentation_ratio 大于 1 但小于 1.5。** 这种情况是合理的。这是因为，内因的内存分配器是一定要使用的，分配策略都是通用的，不会轻易修改；而外因由 Redis 负载决定，也无法限制。所以，存在内存碎片也是正常的。
+ **mem_fragmentation_ratio 大于 1.5 。** 这表明内存碎片率已经超过了 50%。一般情况下，这个时候，就需要采取一些措施来降低内存碎片率了。

## 如何清理内存碎片？

当 Redis 发生内存碎片后，一个“简单粗暴”的方法就是重启 Redis 实例，但是这肯定不是一个"优雅"的方法，这样操作会带来两个后果：
+ 如果 Redis 中的数据没有持久化，那么，数据就会丢失；
+ 即使 Redis 数据持久化了，还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。

那怎么办呢？从 `4.0-RC3` 版本以后，Redis 自身提供了一种内存碎片自动清理的方法，这个方法的基本机制如下：
> 内存碎片清理，简单来说，就是“搬家让位，合并空间”。

还以刚才的高铁车厢选座为例，来解释一下。你和小伙伴不想耽误时间，所以直接买了座位不在一起的三张票。但是，上车后，你和小伙伴通过和别人调换座位，又坐到了一起。

> 这么一说，碎片清理的机制就很容易理解了。当有数据把一块连续的内存空间分割成好几块不连续的空间时，操作系统就会把数据拷贝到别处。此时，数据拷贝需要能把这些数据原来占用的空间都空出来，把原本不连续的内存空间变成连续的空间。否则，如果数据拷贝后，并没有形成连续的内存空间，这就不能算是清理了。

![内存碎片清理示意图](.pic/2023-03-20-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E6%B8%85%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

**需要注意的是：**

>碎片清理是有代价的，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为 Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。而且，有的时候，数据拷贝还需要注意顺序，就像刚刚说的清理内存碎片的例子，操作系统需要先拷贝 D，并释放 D 的空间后，才能拷贝 B。这种对顺序性的要求，会进一步增加 Redis 的等待时间，导致性能降低。

但是，不用担心，Redis 专门为自动内存碎片清理功能机制设置了参数，可以通过设置参数，来控制碎片清理的开始和结束实际，以及占用的 CPU 比例，从而减少碎片清理对 Redis 本身请求处理的性能影响：
```
config set activedefrag yes
```
这个命令只是启用了自动清理功能，但是，具体什么时候清理，会受到下面这两个参数的控制。**这两个参数分别设置了触发内存清理的一个条件，如果同时满足这两个条件，就开始清理。在清理的过程中，只要有一个条件不满足了，就停止自动清理**：
+ **active-defrag-ignore-bytes 100mb：** 表示内存碎片的字节数达到 `100MB` 时，开始清理；
+ **active-defrag-threshold-lower 10：** 表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 `10%` 时，开始清理。

自动内存碎片清理功能在执行时，还会监控清理操作占用的 `CPU` 时间，而且还设置了两个参数，分别用于控制清理操作占用的 `CPU` 时间比例的上、下限，既保证清理工作能正常进行，又避免了降低 Redis 性能。这两个参数具体如下：
+ **active-defrag-cycle-min 25：** 表示自动清理过程所用 `CPU` 时间的比例不低于 `25%`，保证清理能正常开展；
+ **active-defrag-cycle-max 75：** 表示自动清理过程所用 `CPU` 时间的比例不高于 `75%`，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高。