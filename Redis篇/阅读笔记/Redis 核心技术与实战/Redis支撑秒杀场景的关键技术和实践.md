## 秒杀场景的负载特征对支撑系统的要求

第一个特征是瞬时并发访问量非常高。

> 一般数据库每秒只能支撑千级别的并发请求，而 `Redis` 的并发处理能力（每秒处理请求数）能达到万级别，甚至更高。所以，当有大量并发请求涌入秒杀系统时，我们就需要使用 `Redis` 先拦截大部分请求，避免大量请求直接发送给数据库，把数据库压垮。

第二个特征是读多写少，而且读操作是简单的查询操作。

> 在秒杀场景下，用户需要先查验商品是否还有库存（也就是根据商品 `ID` 查询该商品的库存还有多少），只有库存有余量时，秒杀系统才能进行库存扣减和下单操作。
>
> 库存查验操作是典型的键值对查询，而 `Redis` 对键值对查询的高效支持，正好和这个操作的要求相匹配。
>
> 不过，秒杀活动中只有少部分用户能成功下单，所以，商品库存查询操作（读操作）要远多于库存扣减和下单操作（写操作）。

## Redis 可以在秒杀场景的哪些环节发挥作用？

秒杀活动分成三个阶段。在每一个阶段，Redis 所发挥的作用也不一样：

1. 第一阶段是秒杀活动前。
   + 在这个阶段，用户会不断刷新商品详情页，这会导致详情页的瞬时请求量剧增。这个阶段的应对方案，一般是尽量把商品详情页的页面元素静态化，然后使用 `CDN` 或是浏览器把这些静态化的元素缓存起来。这样一来，秒杀前的大量请求可以直接由 `CDN` 或是浏览器缓存服务，不会到达服务器端了，这就减轻了服务器端的压力。在这个阶段，有 `CDN` 和浏览器缓存服务请求就足够了，还不需要使用 `Redis`。

2. 第二阶段是秒杀活动开始。
   + 这个阶段的操作就是三个：`库存查验、库存扣减和订单处理`。因为每个秒杀请求都会查询库存，而请求只有查到有库存余量后，后续的库存扣减和订单处理才会被执行。所以，这个阶段中最大的并发压力都在库存查验操作上。为了 ***支撑大量高并发的库存查验请求***，需要在这个环节使用 `Redis` 保存库存量，这样一来，请求可以直接从 `Redis` 中读取库存并进行查验。
   + 订单处理可以在数据库中执行，但库存扣减操作，不能交给后端数据库处理。
     + 订单处理会涉及支付、商品出库、物流等多个关联操作，这些操作本身涉及数据库中的多张数据表，要保证处理的事务性，需要在数据库中完成。而且，订单处理时的请求压力已经不大了，数据库可以支撑这些订单处理请求。
     + 数据库执行库存扣减操作会带来两个问题：(所以一般是直接在Redis中操作)
       + 1、额外的开销。`Redis `中保存了库存量，而库存量的最新值又是数据库在维护，所以数据库更新后，还需要和 `Redis` 进行同步，这个过程增加了额外的操作逻辑，也带来了额外的开销。
       + 2、下单量超过实际库存量，出现超售。由于数据库的处理速度较慢，不能及时更新库存余量，这就会导致大量库存查验的请求读取到旧的库存值，并进行下单。此时，就会出现下单数量大于实际的库存量，导致出现超售，这就不符合业务层的要求了。

3. 第三阶段就是秒杀活动结束后。
   + 在这个阶段，可能还会有部分用户刷新商品详情页，尝试等待有其他用户退单。而已经成功下单的用户会刷新订单详情，跟踪订单的进展。不过，这个阶段中的用户请求量已经下降很多了，服务器端一般都能支撑。

![Redis参与秒杀环节](.pic/2023-03-29-Redis%E5%8F%82%E4%B8%8E%E7%A7%92%E6%9D%80%E7%8E%AF%E8%8A%82.png)

## Redis 的哪些方法可以支撑秒杀场景？
1. **支持高并发。** 这个很简单，`Redis` 本身高速处理请求的特性就可以支持高并发。而且，如果有多个秒杀商品，也可以使用切片集群，用不同的实例保存不同商品的库存，这样就避免，使用单个实例导致所有的秒杀请求都集中在一个实例上的问题了。不过，需要注意的是，当使用切片集群时，要先用 `CRC` 算法计算不同秒杀商品 `key` 对应的 `Slot`，然后，我们在分配 `Slot` 和实例对应关系时，才能把不同秒杀商品对应的 `Slot` 分配到不同实例上保存。

2. 保证库存查验和库存扣减原子性执行。针对这条要求，就可以使用 `Redis` 的原子操作或是分布式锁这两个功能特性来支撑了。

### 基于原子操作支撑秒杀场景

> 因为库存查验和库存扣减是两个操作，无法用一条命令来完成，所以，就需要使用 `Lua` 脚本原子性地执行这两个操作。

示例伪代码：
```
#获取商品库存信息        
local counts = redis.call("HMGET", KEYS[1], "total", "ordered");
#将总库存转换为数值
local total = tonumber(counts[1])
#将已被秒杀的库存转换为数值
local ordered = tonumber(counts[2])  
#如果当前请求的库存量加上已被秒杀的库存量仍然小于总库存量，就可以更新库存     
if ordered + k <= total then
    #更新已秒杀的库存量
    redis.call("HINCRBY",KEYS[1],"ordered",k)                              return k;  
end           
return 0
```

### 基于分布式锁来支撑秒杀场景

> 使用分布式锁来支撑秒杀场景的具体做法是，先让客户端向 `Redis` 申请分布式锁，只有拿到锁的客户端才能执行库存查验和库存扣减。这样一来，大量的秒杀请求就会在争夺分布式锁时被过滤掉。而且，库存查验和扣减也不用使用原子操作了，因为多个并发客户端只有一个客户端能够拿到锁，已经保证了客户端并发访问的互斥性。

示例伪代码：
```
//使用商品ID作为key
key = itemID
//使用客户端唯一标识作为value
val = clientUniqueID
//申请分布式锁，Timeout是超时时间
lock =acquireLock(key, val, Timeout)
//当拿到锁后，才能进行库存查验和扣减
if(lock == True) {
   //库存查验和扣减
   availStock = DECR(key, k)
   //库存已经扣减完了，释放锁，返回秒杀失败
   if (availStock < 0) {
      releaseLock(key, val)
      return error
   }
   //库存扣减成功，释放锁
   else{
     releaseLock(key, val)
     //订单处理
   }
}
//没有拿到锁，直接返回
else
   return
```

在使用分布式锁时，客户端需要先向 `Redis` 请求锁，只有请求到了锁，才能进行库存查验等操作，这样一来，客户端在争抢分布式锁时，大部分秒杀请求本身就会因为抢不到锁而被拦截。

> 所以，一个小建议，可以使用***切片集群中的不同实例来分别保存分布式锁和商品库存信息***。使用这种保存方式后，秒杀请求会首先访问保存分布式锁的实例。如果客户端没有拿到锁，这些客户端就不会查询商品库存，这就可以减轻保存库存信息的实例的压力了。