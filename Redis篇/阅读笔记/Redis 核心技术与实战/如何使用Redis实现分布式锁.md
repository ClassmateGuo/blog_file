## 单机上的锁和分布式锁的联系与区别

### 单机锁
对于在单机上运行的多线程程序来说，锁本身可以用一个变量表示：

+ 变量值为 0 时，表示没有线程获取锁；
+ 变量值为 1 时，表示已经有线程获取到锁了。

通常说的线程调用加锁和释放锁的操作，到底是啥意思呢？实际上，一个线程调用**加锁操作**，其实就是检查锁变量值是否为 `0`。如果是` 0`，就把锁的变量值设置为 `1`，表示**获取到锁**，如果不是 `0`，就返回错误信息，表示**加锁失败**，已经有别的线程获取到锁了。而一个线程调用释放锁操作，其实就是将锁变量的值置为 `0`，以便其它线程可以来获取锁。

### 分布式锁

分布式锁同样可以用一个变量来实现。客户端加锁和释放锁的操作逻辑，也和单机上的加锁和释放锁操作逻辑一致：加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设置为` 0`，表明客户端不再持有锁。

> 但是，和线程在单机上操作锁不同的是，在分布式场景下，***锁变量需要由一个共享存储系统来维护***，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，加锁和释放锁的操作就变成了`读取、判断和设置`共享存储系统中的锁变量值。

从此可以了解到，实现分布式锁的两个要求：

+ 要求一：分布式锁的加锁和释放锁的过程，涉及多个操作。所以，在实现分布式锁时，我们需要保证这些锁操作的原子性；
+ 要求二：共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。


## 基于单个 Redis 节点实现分布式锁
> 作为分布式锁实现过程中的共享存储系统，Redis 可以使用键值对来保存锁变量，再接收和处理不同客户端发送的加锁和释放锁的操作请求。

### 加锁操作分析
![键值对保存锁变量加锁示意图](.pic/2023-03-27-%E9%94%AE%E5%80%BC%E5%AF%B9%E4%BF%9D%E5%AD%98%E9%94%81%E5%8F%98%E9%87%8F%E5%8A%A0%E9%94%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

可以看到，Redis 可以使用一个键值对 `lock_key:0 `来保存锁变量，其中，键是 `lock_key`，也是锁变量的名称，锁变量的初始值是 `0`。


在图中，客户端 `A` 和 `C` 同时请求加锁。因为 Redis 使用单线程处理请求，所以，即使客户端 `A` 和 `C` 同时把加锁请求发给了 Redis，Redis 也会串行处理它们的请求。

假设 Redis 先处理客户端 `A` 的请求，读取 `lock_key` 的值，发现 `lock_key` 为 `0`，所以，Redis 就把 `lock_key` 的 `value` 置为 `1`，表示已经加锁了。紧接着，Redis 处理客户端 `C` 的请求，此时，Redis 会发现 `lock_key` 的值已经为 `1` 了，所以就返回加锁失败的信息。

### 释放锁操作分析

![键值对保存变量释放锁示意图](.pic/2023-03-27-%E9%94%AE%E5%80%BC%E5%AF%B9%E4%BF%9D%E5%AD%98%E5%8F%98%E9%87%8F%E9%87%8A%E6%94%BE%E9%94%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

当客户端 `A` 持有锁时，锁变量 `lock_key` 的值为 `1`。客户端 `A` 执行释放锁操作后，Redis 将 `lock_key` 的值置为 `0`，表明已经没有客户端持有锁了。

---

因为加锁包含了三个操作（`读取锁变量、判断锁变量值以及把锁变量值设置为 1`），而这三个操作在执行时需要`保证原子性`。那怎么保证原子性呢？

使用 `SETNX` 和 `DEL` 命令组合实现分布锁
+ 存在两个问题：
    + 执行了 `SETNX` 命令、加锁之后，紧接着却在操作共享数据时发生了异常，结果一直没有执行最后的 `DEL` 命令释放锁。导致死锁。
    + 如果客户端 `A` 执行了 `SETNX` 命令加锁后，假设客户端 `B` 执行了 `DEL` 命令释放锁，此时，客户端 `A` 的锁就被误释放了。

**为了解决以上两个问题，可以这样操作：**

在使用 `SETNX` 命令进行加锁的时候，可以带上 `EX` 或 `PX` 选项，用来设置键值对的过期时间（这样，第一个问题就解决了）。然后在加锁操作时，可以让 ***每个客户端给锁变量设置一个唯一值***，这样，在释放锁的时候，客户端需要判断，当前锁变量的值是否和自己的唯一标识相等，只有在相等情况下，才能释放锁（这样第二个问题也解决了）。

> 释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作，而 Redis 在执行 `Lua` 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。命令如下(unlock.script Lua 脚本中的内容代码就不展示了)：
>
>
>```
>redis-cli  --eval  unlock.script lock_key , unique_value 
>```

## 基于多个 Redis 节点实现高可靠的分布式锁

要实现高可靠的分布式锁时，就不能只依赖单个的命令操作了，需要按照一定的步骤和规则进行加解锁操作，否则，就可能会出现锁无法工作的情况。“一定的步骤和规则”是指啥呢？其实就是分布式锁的算法。

> 为了避免 Redis 实例故障而导致的锁无法工作的问题，Redis 的开发者 `Antirez` 提出了分布式锁算法 `Redlock` 。

Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么就认为，客户端成功地获得分布式锁了，否则加锁失败。
> 这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。

**Redlock具体的执行步骤：**
+ 第一步是，客户端获取当前时间。
+ 第二步是，客户端按顺序依次向 `N` 个 Redis 实例执行加锁操作。(
  + 这里的加锁操作和在单实例上执行的加锁操作一样，使用 `SET` 命令，带上 `NX`，`EX/PX` 选项，以及带上客户端的 ***唯一标识***。
+ 第三步是，一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。
  + 客户端只有在满足下面的这两个条件时，才能认为是加锁成功。
    + 条件一：客户端从超过半数（大于等于 `N/2+1` ）的 Redis 实例上成功获取到了锁；
    + 条件二：客户端获取锁的总耗时没有超过锁的有效时间。