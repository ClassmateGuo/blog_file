# AOF 日志

## Redis 在宕机的情况下，如何避免数据丢失？

`Redis` 我们在业务中普遍当做缓存来使用（将后端数据库中的数据，存储在`Redis` 中，然后直接从`Redis` 中读取数据，响应速度会非常快），但是这里存在一个问题：<font color="red">一旦服务宕机了，内存中的数据将全部丢失</font>。

**如何解决？**
首先能想到的一个解决方案就是从后端数据库恢复这些数据，但是存在两个问题：
- 需要频繁访问后端数据库，给数据库带来巨大的压力。
- 这些数据是从<font color="red">慢速数据库</font>中读取出来的，性能肯定不如从 `Redis` 中读取，导致使用这些数据的应用程序响应变慢。

所以 `Redis` 需要实现对数据的持久化，避免从后端数据库中恢复。

## AOF 日志是如何实现的？

首先，`AOF` 日志是一种“写后”日志：`Redis` 先执行命令，把数据写入内存，然后才记录日志。
![AOF写后日志](.pic/2023-02-18-AOF%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97.png)

**`Redis` 为什么要先执行命令再写日志呢？**

首先，了解一下 `AOF` 日志内容是怎样的。

`AOF` 日志里记录的是 `Redis` 收到的每一条命令，这些命令以文本形式保存。以`“set testkey testvalue”` 命令后记录的日志举个例子：
![AOF日志内容](.pic/2023-02-18-AOF%E6%97%A5%E5%BF%97%E5%86%85%E5%AE%B9.png)

>如上图所示，其中，“*3”表示当前命令有三个部分，每部分都是由$+数字开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。

`Redis` 在向 `AOF` 里面记录日志的时候，为了避免<font color="red">额外的检查开销</font>，并不会先去对这些命令进行语法检查。所以，如果先写日志，再执行命令的话，就可能出现日志中记录了<font color="red">错误的命令</font>，而 `Redis` 在使用 `AOF` 日志进行数据恢复的时候，导致报错。

所以，<font color="red">先执行命令，再写日志</font>的话，就是让系统先执行命令，只有命令成功了，才会被记录到日志中。

**这样，存在两个好处：**
1. `AOF` 日志里面记录的命令都是正确的;
2. 执行完后才记录日志，不会阻塞当前的写操作。

### AOF 存在的风险

看上去 `AOF` 日志好像挺不错的，但是它依旧存在着两个风险：
1. 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有<font color="red">丢失的风险</font>（如果 `Redis` 作为数据库使用的话）;
2. `AOF` 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来<font color="red">阻塞风险</font>(这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了)。


### AOF 的三种写回策略
对于上面的风险问题， `AOF` 配置项 `appendfsync` 提供了三个可选值：
1. `Always`(总是)，<font color="red">同步写回</font>：每个写命令执行完，立马同步地将日志写回磁盘；
2. `Everysec`（每秒钟），<font color="red">每秒写回</font>：每个写命令执行完，只是先把日志写到 `AOF` 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
3. `No`（不），<font color="red">操作系统控制的写回</font>：每个写命令执行完，只是先把日志写到 `AOF` 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

虽然有三种写回策略供我们选择，但是，针对<font color="red">避免主线程阻塞和减少数据丢失</font>问题，这三种写回策略都无法做到两全其美。

**原因如下：**
- “同步写回”可以做到<font color="red">基本不丢数据</font>，但是它在<font color="red">每一个写命令后都有一个慢速的落盘操作</font>，不可避免地会<font color="red">影响主线程性能</font>；

- 虽然“操作系统控制的写回”在写完缓冲区后，就可以<font color="red">继续执行后续的命令</font>，但是<font color="red">落盘的时机</font>已经不在 `Redis` 手中了，只要 `AOF` 记录没有写回磁盘，一旦<font color="red">宕机</font>对应的数据就<font color="red">丢失</font>了；

- “每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然<font color="red">减少了对系统性能的影响</font>，但是如果发生<font color="red">宕机</font>，上一秒内未落盘的命令操作仍然会<font color="red">丢失</font>。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个<font color="red">折中</font>。

![AOF写回策略](.pic/2023-02-18-AOF%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5.png)

根据上图，我们可以根据系统对<font color="red">高性能</font>和<font color="red">高可靠性</font>的要求，来选择使用哪种写回策略了：

- 想要获得<font color="red">高性能</font>，就选择 `No` 策略；
- 如果想要得到<font color="red">高可靠性</font>保证，就选择 `Always` 策略；
- 如果<font color="red">允许数据有一点丢失，又希望性能别受太大影响</font>的话，那么就选择 `Everysec` 策略。

但是，不是选择了"对的"写回策略就"高枕无忧"了，因为，`AOF` 是以文件的形式来记录接收到的所有写命令，那么，随着接收的命令越来越多，`AOF` 文件会越来越大，一旦 `AOF` 文件过大，会带来"性能问题"：
1. 文件系统本身对文件大小有限制，无法保存过大的文件；
2. 文件如果太大，之后在往里面追加命令记录的效率会变低；
3. 如果发生宕机，`AOF` 中记录的命令要一个个被重新执行，用于故障恢复，日志文件过大，整个恢复过程会非常缓慢，影响 `Redis` 正常使用。

**解决方法接着往下看👇🏻**

## AOF 日志文件太大了怎么办？

日志文件太大了怎么办？ 看 `AOF` 重写机制。

### 重写机制

> `AOF` 重写机制就是在重写时，`Redis` 根据数据库的现状创建一个新的 `AOF` 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。

重写机制是如何将日志文件变小的？
> 因为 `AOF` 文件是以<font color="red">追加的方式</font>，逐一记录接收到的命令，如果有<font color="red">一个键值对</font>被<font color="red">多条写命令反复修改</font>的时候，`AOF` 日志文件就会记录多条命令（a:1 -> a:2 -> a:3 -> a:4）， 但是，<font color="red">重写机制重写的时候</font>，是根据这个键值对<font color="red">当前最新的状态</font>（a:4)，为它生成对应的写入命令，这样<font color="red">一个键值对</font>在<font color="red">重写日志</font>中只会<font color="red">存在一条命令</font>，并且，在进行日志恢复的时候，只要执行这一条命令就行了。

![重写机制重写过程例子](.pic/2023-02-18-AOF%E6%97%A5%E5%BF%97%E5%A4%A7%E5%B0%8F%E7%BC%A9%E5%B0%8F%E4%B8%BE%E4%BE%8B.png)

如图所示，本来记录了6条命令，重写后，只记录了1条命令，等于节省了5条命令的空间。对于真实业务场景中被修改过 N 多次的键值对来说，那就节省了非常多的空间（所以说，重写机制可以减少日志的大小就是这样来的）。

### 重写会阻塞主线程嘛？

重写机制重写后，`AOF` 日志文件大小会变小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程，所以，重写机制会不会阻塞主线程呢？

>`AOF` 日志是由主线程写回的，但是，重写过程是由后台子进程 `bgrewriteaof` 来完成的，所以重写不会阻塞主线程（但是，在主线程fork 子进程的时候也是一个潜在的阻塞点）。

**重写过程：**

**“一次拷贝，两次日志”**

1. 每次执行重写时，主线程 `fork` 出后台的 `bgrewriteaof` 子进程。此时，`fork` 会把主线程的<font color="red">内存拷贝</font>一份给 `bgrewriteaof` 子进程，这里面就包含了数据库的最新数据。然后，`bgrewriteaof` 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。("一次拷贝")；
2. 因为主线程未阻塞，仍然可以<font color="red">处理新来的操作</font>。此时，如果有写操作，第一处日志就是指正在使用的 `AOF` 日志， `Redis` 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。( `AOF` 日志)；
3. 这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 `AOF` 文件，以保证数据库<font color="red">最新状态的记录</font>。此时，我们就可以用新的 `AOF` 文件替代旧文件了。(重写日志)。

![重写过程](.pic/2023-02-18-%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.png)

