# 数据类型与底层数据结构

## 对应关系
- String
  - 简单动态字符串
- Set
  - 整数数组
- List
  - 双向链表
  - 压缩列表
- Hasha
  - 哈希表
  - 压缩列表
- Sorted Set
  - 跳表
  - 压缩列表


## 有哪些底层数据结构？
集合类型的底层数据结构主要与5 种：<font color="red">整数数组，双向链表，压缩列表，跳表，哈希表</font>。

1. 整数数组和双向链表的特征是：<font color="red">顺序读写</font>，

2. 压缩列表实际上类似于数组，但是压缩列表在<font color="red">表头</font>有3 个字段<font color="red">（zlbytes，zltail，zllen）</font>，分别表示<font color="red">列表长度，列表尾部的偏移量和列表中entry 的个数</font>;  压缩列表在<font color="red">尾部</font>也有1 个字段<font color="red">（zlend）</font>，表示<font color="red">列表结束</font>。

3. 有序链表只能逐一查找元素，这样操作起来非常缓慢，于是出现了跳表；跳表在链表的基础上增加了<font color="red">多级索引</font>，通过索引位置的几个<font color="red">跳转</font>，实现数据的快速定位。

4. 哈希表会在下文具体讲述。

### 数据结构的时间复杂度
![数据结构时间复杂度](.pic/2023-02-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png)

**集合场景操作的复杂度”口诀“:**
- 单元素操作是基础
  - 指每一种集合类型对单个数据实现的增删改查操作。
- 范围操作非常耗时
  - 指比集合类型中的便利操作，可以返回集合中的所有数据。（比较耗时，尽量避免）
- 统计操作通常高效
  - 指集合类型对集合中所有元素个数的记录。
- 例外情况只有几个
  - 指某些特殊数据结构的特殊记录。（例如压缩列表和双向链表都会记录表头和表尾的偏移量）

## 键和值用什么结构组织？

为了实现从键到值的快速访问，Redis 使用了一个<font color="red">哈希表</font>来保存所有键值对。

> <font color="red">哈希表</font>：其实就是一个数组，数组的每个元素称之为<font color="red">哈希捅</font>，每个<font color="red">哈希桶</font>中保存了键值对数据。

但是，从上面的对应关系可以得知，值不只是单类型结构，也存在集合类型结构，那如果值是集合类型的情况下，作为数组元素的哈希桶如何来保存呢？

其实，<font color="red">哈希桶</font>中保存的并不是<font color="red">具体的值</font>，而是指向<font color="red">具体值</font>的<font color="red">指针</font>

![全局哈希表](.pic/2023-02-16-%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.jpg)

那我们如何去查找呢？
只需要计算<font color="red">键</font>的哈希值（查找的过程依赖于哈希计算，与数据量没有太多直接关系，所以这个查找过程的时间复杂度是O(1)），就能知道键对应的哈希桶的位置，然后就可以访问到对应的值。<br>

看到这，觉得贼牛逼！但是，当往Redis 中写入大量数据后，可能会发现操作变慢了。因为这里存在一个问题：<font color="red">哈希表的冲突</font>与<font color="red">rehash 可能带来的操作阻塞</font>。

## 哈希表操作为什么变慢了？
为什么当大量数据写入Redis 的时候，哈希表操作变慢了？因为<font color="red">哈希桶的个数通常要少于key 的数量</font>，这就难免会发生多个key 的哈希值与哈希捅计算对应关系的时候，正好落在了同一个哈希桶里。

**如何解决冲突问题？**

Redis 采用的解决方式是<font color="red">链式哈希</font>，就是指同<font color="red">一个哈希桶</font>中的<font color="red">多个元素用一个链表</font>来保存，它们之间依次用<font color="red">指针连接</font>。
![链式哈希](.pic/2023-02-16-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3.png)

这样不就OK 啦？不不不，这里依旧存在一个问题，全局哈希表是通过计算键的哈希值，但是随着数据的越写越多，哈希冲突链表可能就会越来越长，就会导致链上的元素查找耗时变长，效率降低。

**如何解决效率低问题？**

Redis 会对哈希表做<font color="red">rehash（重新整理)</font>的操作，Redis 默认使用了两个全局哈希表（哈希表1 和哈希表2）。一开始插入数据的时候，默认使用的是哈希表1（此时哈希表2 没有被分配空间），随着数据逐步增多，Redis 就会开始执行rehash，过程如下：

1.  给哈希表2 分配更大的空间（假设是哈希表1 的2倍）；
2.  把哈希表1 中的数据<font color="red">重新映射并拷贝</font>到哈希表2 中；
3.  释放哈希表1 的空间；
4.  如果当哈希表2 的数据越来越多了，重复上面的3 个步骤。

该过程中存在一个问题，<font color="red">步骤2</font> 涉及大量的<font color="red">数据拷贝</font>操作，如果一次性将哈希表1 中的数据全部迁移到哈希表2 中，会导致Redis 主线程<font color="red">阻塞</font>，无法服务其他请求。

**渐进式rehash 解决步骤2 的问题**

在步骤2 进行数据拷贝时，Redis 仍可以正常处理客户端请求，每处理一个请求，从哈希表1 中的第一个索引位置开始，顺带着将这个索引位置上的所有entries 拷贝到哈希表2 中，等处理下一个请求时，在顺带拷贝哈希表1 中的下一个索引位置的entries。

## 留疑 ⭐
渐进式rehash 具体的执行过程不太理解。