## 缓存的特征

### 以计算机系统为例子，解释缓存的特征

以下是计算机系统中三层结果，以及它们各自的常用容量和访问性能：

![计算机系统中的三层存储结构](.pic/2023-03-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

可以发现，CPU的访问速度是最快的，其次是内存，再就是磁盘。如果每次 CPU 处理数据时，都要从 ms 级别的慢速磁盘中读取数据，然后再进行处理，那么，CPU 只能等磁盘的数据传输完成。这样一来，高速的 CPU 就被慢速的磁盘拖累了，整个计算机系统的运行速度会变得非常慢。所以，计算机系统中，默认有两种缓存：
+ CPU 里面的末级缓存，即 `LLC`，用来缓存内存中的数据，避免每次从内存中存取数据；
+ 内存中的高速页缓存，即 `page cache`，用来缓存磁盘中的数据，避免每次从磁盘中存取数据。

![两级缓存](.pic/2023-03-22-%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98.png)

可以发现缓存的***第一个特征***：在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。


在通过观察计算机分层结构。`LLC` 的大小是 `MB` 级别，`page cache` 的大小是 `GB` 级别，而磁盘的大小是 `TB` 级别。
这其实包含了缓存的***第二个特征***：缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。

## Redis 缓存处理请求的两种情况

把 Redis 用作缓存时，会把 Redis 部署在数据库的前端，业务应用在访问数据时，会先查询 Redis 中是否保存了相应的数据。此时，根据数据是否存在缓存中，会有两种情况：
+ 缓存命中：Redis 中有相应数据，就直接读取 Redis，性能非常快。
+ 缓存缺失：Redis 中没有保存相应数据，就从后端数据库中读取数据，性能就会变慢。而且，一旦发生缓存缺失，为了让后续请求能从缓存中读取到数据，需要把缺失的数据写入 Redis，这个过程叫作缓存更新。

![命中、命中缺失示意图](.pic/2023-03-22-%E5%91%BD%E4%B8%AD%E3%80%81%E5%91%BD%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

## Redis 作为旁路缓存的使用操作
Redis 是一个独立的系统软件，和业务应用程序是两个软件，当我们部署了 Redis 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 Redis 缓存，就要在程序中增加相应的缓存操作代码。
> 所以，也把 Redis 称为旁路缓存，也就是说，读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。


## 缓存的类型

按照 Redis 缓存是否接受写请求，可以把它分成只读缓存和读写缓存。
+ 只读缓存
  + 应用要读取数据，就会先调用 Redis 的 GET 接口，查询数据是否存在，存在变返回，反之，需要读取数据库，在写入缓存中。（好处是，所有的数据都是存储在数据库中，数据库是提供数据可靠性保证的）
+ 读写缓存
  + 最新的数据是存储在 Redis 中的，Redis 是内存数据库，容易出现数据丢失问题。根据业务对数据可靠性和缓存性能的不同要求，有***同步直写*** 和 ***异步写回*** 两种策略。
    + 同步直写
      + 写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回；（这样，即使缓存宕机或发生故障，最新的数据仍然保存在数据库中，这就提供了数据可靠性保证，但是会降低访问性能）
    + 异步写回
      + 优先考虑了响应延迟，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。（有数据丢失风险）


![写缓存策略](.pic/2023-03-22-%E5%86%99%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png)