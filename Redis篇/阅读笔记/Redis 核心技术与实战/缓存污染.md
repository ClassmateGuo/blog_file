
## 什么是缓存污染？
那什么是缓存污染呢？在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。这种情况，就是缓存污染。

> 当缓存污染不严重的时候，只是少量数据占据缓存空间，影响不大；但是，缓存污染一旦变得严重，就会有大量不再访问的数据滞留在缓存中，如果此时缓存空间已经被占满了，插入新数据的时候，就要进行数据淘汰，会影响应用的性能。


## 如何解决缓存污染？

### LRU 缓存策略

> `LRU` 策略的核心思想：如果一个数据刚刚被访问，那么这个数据肯定是热数据，还会被再次访问。

按照这个核心思想，Redis 中的 `LRU` 策略，会在每个数据对应的 `RedisObject` 结构体中设置一个 `lru` 字段，用来记录数据的访问时间戳。在进行数据淘汰时，`LRU` 策略会在候选数据集中淘汰掉 `lru` 字段值最小的数据（也就是访问时间最久的数据）。

所以，在数据被频繁访问的业务场景中，`LRU `策略的确能有效留存访问时间最近的数据。而且，因为留存的这些数据还会被再次访问，所以又可以提升业务应用的访问速度。

> 但是，也正是因为只看数据的访问时间，使用 `LRU` 策略在处理扫描式单次查询操作时，无法解决缓存污染。所谓的 ***扫描式单次查询操作***，就是指应用对大量的数据进行一次全体读取，每个数据都会被读取，而且只会被读取一次。此时，因为这些被查询的数据刚刚被访问过，所以 `lru `字段值都很大。
>
> 在使用 `LRU` 策略淘汰数据时，这些数据会留存在缓存中很长一段时间，造成缓存污染。如果查询的数据量很大，这些数据占满了缓存空间，却又不会服务新的缓存请求，此时，再有新数据要写入缓存的话，还是需要先把这些旧数据替换出缓存才行，这会影响缓存的性能。

![LRU缓存污染](.pic/2023-03-26-LRU%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93.png)


### LFU 缓存策略的优化
`LFU` 缓存策略是在 `LRU` 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 `LFU` 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，`LFU `策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。

为了避免操作链表的开销，Redis 在实现 LRU 策略时使用了两个近似方法：

+ Redis 是用 `RedisObject` 结构来保存数据的，`RedisObject `结构中设置了一个 `lru` 字段，用来记录数据的访问时间戳；
+ Redis 并没有为所有的数据维护一个全局的链表，而是通过随机采样方式，选取一定数量（例如 `10` 个）的数据放入候选集合，后续在候选集合中根据 `lru` 字段值的大小进行筛选。


在此基础上，Redis 在实现 `LFU` 策略的时候，只是把原来 `24bit` 大小的 `lru` 字段，又进一步拆分成了两部分。
1. ldt 值：`lru` 字段的前 `16bit`，表示数据的访问时间戳；
2. counter 值：`lru `字段的后 `8bit`，表示数据的访问次数。

Redis 只使用了 `8bit` 记录数据的访问次数，而 `8bit` 记录的最大值是 `255`，好像是不太够用的，那是怎么处理的呢？

> 在实现 `LFU` 策略时，Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，而是采用了一个更优化的计数规则。
>
> 简单来说，`LFU` 策略实现的计数规则是：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 `lfu_log_factor` 再加 `1`，再取其倒数，得到一个 `p` 值；然后，把这个 `p` 值和一个取值范围在`（0，1）`间的随机数 r 值比大小，只有 `p` 值大于 `r` 值时，计数器才加 `1`。

![LFU策略计数器值的变化表](.pic/2023-03-26-LFU%E7%AD%96%E7%95%A5%E8%AE%A1%E6%95%B0%E5%99%A8%E5%80%BC%E7%9A%84%E5%8F%98%E5%8C%96%E8%A1%A8.png)

可以看到，当 `lfu_log_factor` 取值为 `1` 时，实际访问次数为 `100K `后，`counter` 值就达到 `255` 了，无法再区分实际访问次数更多的数据了。而当 `lfu_log_factor` 取值为 `100` 时，当实际访问次数为 `10M` 时，`counter` 值才达到 `255`，此时，实际访问次数小于 `10M` 的不同数据都可以通过 `counter` 值区分出来。

> 正是因为使用了非线性递增的计数器方法，即使缓存数据的访问次数成千上万，`LFU` 策略也可以有效地区分不同的访问次数，从而进行合理的数据筛选。在应用 `LFU` 策略时，一般可以将 `lfu_log_factor` 取值为 `10`。


前面也提到了，**应用负载**的情况是很复杂的。在一些场景下，有些数据在短时间内被大量访问后就不会再被访问了。那么再按照访问次数来筛选的话，这些数据会被留存在缓存中，但不会提升缓存命中率。为此，Redis 在实现 LFU 策略时，还设计了一个 `counter` 值的 ***衰减机制***。

> 简单来说，`LFU` 策略使用衰减因子配置项 `lfu_decay_time` 来控制访问次数的衰减。`LFU `策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，`LFU `策略再把这个差值除以 `lfu_decay_time` 值，所得的结果就是数据 `counter` 要衰减的值。

**举个例子：**
> 假设 `lfu_decay_time` 取值为` 1`，如果数据在 `N` 分钟内没有被访问，那么它的访问次数就要减 `N`。如果 `lfu_decay_time` 取值更大，那么相应的衰减值会变小，衰减效果也会减弱。所以，如果业务应用中有短时高频访问的数据的话，建议把 `lfu_decay_time` 值设置为 `1`，这样一来，`LFU` 策略在它们不再被访问后，会较快地衰减它们的访问次数，尽早把它们从缓存中淘汰出去，避免缓存污染。